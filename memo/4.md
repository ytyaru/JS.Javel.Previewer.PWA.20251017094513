# 分割ページ表示方法

1. ページ分割方式
2. ページ生成方式（タイミングと量）（最初に一括／遷移時一頁／遷移時一頁＋）
3. ページ表示方式（`display:none/block`／`visibility:hidden/visible`）

## 1. ページ分割方式

　Javelのキモは既存のWEB小説がスクロールバー表示のせいで「既読と未読の境界線が判り難い」問題を解決する点にある。画面の端で「文字が見切れてしまう」のも醜い。

　もし本であれば、位置はきっちり固定なので、読み始めの位置は一目で判る。WEB小説でもこうした読書体験がしたくて、画面サイズの範囲内で表示できるように計算してHTML要素を配置したのがJavelである。

　ただ、座標計算する性質上、パフォーマンス問題が発生してしまった。また、文字を拡大縮小したいときは再び長大な座標計算を要する。現在はこの方式で計算している。

　もしスクロールのまま座標計算せずに文字を拡大縮小できて、すぐに閲覧でき、かつ「既読と未読の境界線が判り難い」問題を解決する方法があれば、それも選択肢に入れたい。

　たとえば、スクロールで一括表示しつつ、`content-visibility`を設定することで、画面表示領域外のコンテンツ描画を遅延させるとか。

```css
.page {
  content-visibility: auto;
  contain-intrinsic-size: 1920px 1080px;
}
```

* https://qiita.com/nolanlover0527/items/25dcdc9793d3147bd04d
    * content-visibility はアクセシビリティ的には非表示ではない（スクリーンリーダーには読まれる）
    * SEO対策では非表示扱いされない（Googleは描画しない要素も見る）
    * JavaScriptによるDOM取得（getBoundingClientRectなど）は注意（表示されてないとゼロになる）

　最後の注意点により`getBoundingClientRect`が使えないことから、ページ数を算出することはできないと判る。

　スクロール方式で問題になるのがスクロール移動量と現在位置と最後のページのサイズについて。

* スクロール移動量は画面サイズと同じ分だけピッタリ合わせること
* 最後のページのブロック方向サイズは、一ページ分ぴったりになるよう余白を設けること
    * さもないと最後のページを表示したとき前ページの後ろ部分が表示されてしまう
    * 計算方法は、全体のブロックサイズを画面サイズで割った余りがそれ
* 現在位置は上記条件が揃えば算出できる
    * 計算方法は、全体のブロックサイズを画面サイズで割った商がそれ

　さらに根本的な問題である「既読と未読の境界線が判り難い」「文字が見切れてしまう」をどう解決するか。

* 既読と未読の境界線が判り難い＆文字が見切れてしまう
    * スクロールにより見切れてしまった部分は前後どちらであっても隠す
        * その方法が難しそう。対象部分だけに見えないようなCSSを設定する仕組みをどう実装するか
            * スクロールする度に初回だけ見切れる部分の抽出とHTML要素で囲う処理が必要。
    * 隠された要素は次に表示する。但しピッタリ開始位置にする
        * もし横書きでブロック方向が下なら
            * ページ下部の文字が見切れるので、それを非表示にし、次のページで最上部に表示するようスクロール位置を調整する必要がある
        * もし縦書きでブロック方向が左なら
            * ページ左部の文字が見切れるので、それを非表示にし、次のページで最右部に表示するようスクロール位置を調整する必要がある
    * ページを戻る時にも同じように表示される必要がある

```html
<p>表示される</p>
<p>見切れる</p>
```
```html
<p>表示される</p>
<p>ここまでは表示されるが、ここから先は見切れる</p>
```
```html
<p>表示される</p>
<p>ここまでは表示されるが、<div class="ブロック内の見切れる開始位置">ここから先は見切れる</div></p>
```

　つまり「既読と未読の境界線が判り難い＆文字が見切れてしまう」問題を解決するには、スクロール方式でも座標計算が必要になってしまう。HTML要素数もページ区切り位置に該当する要素が必要になってしまう。よって現在の方式と変わらないため、特に変えるメリットもないはず。しかもページ分割位置を示す要素が子要素になるから分かり難い。

　`content-visibility`だけは設定しておくべきのようにも思うが、それが必要なのはスクロールが必要なときだけ。そもそもJavelはページ計算によって画面外の要素を排除する仕組みだから恩恵もないはず。但しダミー要素で計算するときに`content-visibility`が有効だと計算不能になってしまう点には注意。特に付与するメリットがない。

　どうしてもページ計算は必要になってしまう。問題はページ計算を、いつ、どのくらいやるか。一括か分割か。これによってユーザの体感速度が違うはず。ただ、一括でやらないと全ページ数が事前に判らない問題が起きてしまうが。

　いっそページ分割を完全に無視して、全文章をスクロール形式で出力することも考えられる。そのときは`content-visibility:auto`をセットする。画面サイズに応じて`contain-intrinsic-size`を変更する。

## 2. ページ生成方式（タイミングと量）（最初に一括／遷移時一頁／遷移時一頁＋）

　文庫本一冊分の10〜12万字を一瞬で表示できるパフォーマンスを保ちたい。

1. Javelテキストファイルを全文読み込む
2. Javelテキストを全文テキストブロック化する

　ここまでは一括処理する。それ以降はページ分割処理に時間がかかるため、一括／遅延を切り替え可能にしたい。

方法|長所＆短所
----|----------
一括|最速で実行できるが、その間ユーザ操作不能。完了後に全ページ数が判明するため[現在ページ数／全ページ数]表示可。
一括中にページ遷移操作|実現できなかった。ページ計算中にページ遷移するとバグって空ページが大量生産されてしまう。原因不明。生成済みのページまでなら閲覧可能だと思ったのに…
定時遅延|5秒毎にページ分割処理を一ページずつ進める。5秒間だけユーザ操作可能だが、ページ計算中は操作不能。空ページ大量生産バグが起きると思われる。
操作遅延|ユーザ操作される度に一ページずつ生成する。初回表示は最速だが、それ以降は毎ページ遷移する度に一ページ分のページ計算処理が走り遅くなる。全ページ数は最後まで閲覧しないと不明なままであるため、[現在ページ数／全ページ数]表示不可。代わりにテキストブロック数か原稿字数による読了率を表示する。

　つまり実装可能なのは次の二種類のはず。今実装しているのは一括。

* ページ生成タイミング
    * 一括（最初に全ページを一括で生成する）
    * 操作遅延（次のページへ遷移するユーザ操作が起きた時に一ページ分だけ生成する）

　もしくは操作遅延を拡張する。人間がページを捲ってから一ページ分読むまでの時間を考慮して、複数ページを処理する方法もありうる。但しその間、ユーザ操作ができない。ページ遷移以外にも設定の表示や入力といった操作が不能になってしまう時間ができてしまう。それでもスムーズに次のページを表示可能になることから有用性はある。

　概ね、以下のようなプロセスでページ計算する。

1. 次のページに遷移するユーザ操作が発生した
2. 次の一ページ分を生成する
    1. テキストブロックを一つずつ取得する
    2. HTML要素化する
    4. ダミーページに追記する
    5. ページを超過したら、収まる範囲だけ詰め込む
    6. そのページを表示する
3. 設定次第で、次の次のページも同様に生成する
    1. `document`にこのページのHTML要素を追加するが、非表示の状態とする
4. ここまでの間、ユーザ操作不能になる

　問題は、全ページ数が最後まで判らないことだ。但し原稿全文やテキストブロック数は判明しているため、「読了率」なら算出できる。

　UIをどうするか。ラジオボタンかコンボボックスかリストか。

```
ページ生成方式------------------------------------------------+
|◉ 一括 最初に膨大な時間がかかるが、全ページ数が判明する      |
|○遅延 すぐに表示できるが、ページ初回遷移時に少し時間がかかる|
+-------------------------------------------------------------+
```
```
ページ生成方式------------------------------------------------+
| +------+                                                    |
| |一括▼| 説明文。                                           |
| +------+                                                    |
| |遅延  |                                                    |
| +------+                                                    |
+-------------------------------------------------------------+
```

```
ページ生成方式---------------------------+
| +------------------------------------+ |
| |最初に一括で                        | |
| |遷移時一ページずつ                  | |
| |遷移時一ページ表示後に追加で一ページ| |
| +------------------------------------+ |
| 補足説明。                             |
+----------------------------------------+
ページ計算中はユーザ操作不能になってしまう。
それをいつ、どれくらいの長さにするか決める。
補足説明
* 最初：初回表示まで膨大な時間がかかるが、以降はスムーズで、全ページ数も表示可。
* 一頁：初回表示は最速だが、ページ遷移初回時に少し時間がかかる。
* 追加：ページ遷移後、さらに次のページを読み込むことで、次の次のページ表示を高速化するが、
```

## 3. ページ表示方式（`display:none/block`／`visibility:hidden/visible`）

A. `display:none/block;`
B. `visibiliry:hidden/visitable;`

　後者のほうの実装もしてみたい。ページ遷移時のパフォーマンスは後者のほうが良いはず。前者はリフローが発生するから。でも後者はスクロール表示されてしまう。スクロールバーの幅を算出してページサイズから省くことではみ出さぬようにする必要がある。また、スクロールは必ず一頁サイズ単位であるべき。

### 現状`display`

　まずはHTML要素と親子関係を洗い出す。

```html
<div name="overlay">
  <div name="loading"></div>
</div>
<main>
  <div name="book">
    <div name="error"></div>
    <div name="page spread cover"></div>
    <div name="book-in-pages">
        <div name="page"></div>
        <div name="page spread cover"></div>
        <div name="page"></div>
    </div>
    <div name="footer"></div>
    <div name="dummy"></div>
    <div name="page spread back-cover"></div>
  </div>
</main>
```

### 次回`visibility`

　綺麗に整えたい。

```html
<div name="overlay">
  <div name="loading"></div>
  <div name="error"></div>
  <div name="setting"></div>
</div>
<div class="dummy page"></div>
<main name="javel-page-contents">
    <div name="page spread" data-page-kind="cover"></div>
    <div name="page"></div>
    <div name="page spread"></div>
    <div name="page"></div>
    <div name="page spread" data-page-kind="back-cover"></div>
    <footer></footer>
</main>
```

　また、将来的にはページ分割済みHTMLファイルから原稿生成する機能も欲しい。そのときのデータ算出用`id`や`name`を定義したい。

* ページ設定
* メタ
    * 原稿
        * タイトル、キャッチコピー、著者名、URL等
* ページ内HTML要素
    * `bi`: ブロックID
    * `si`: ブロック内Split番号
    * `ni`: ブロック内ノード番号
    * `mi`: ブロック内原稿開始位置(ManuscriptIndex)
        * `ruby`: `｜漢字《かんじ》`, `漢字《かんじ》`（`<ruby data-bi="1" data-si="2" data-ni="3" data-mi="4" data-ml="4" data-piped>`）
        * `em`: `《《em》》`／`＊em＊`

### AI

#### 質問

```
display:none visibility:hidden パフォーマンス どっちが良いか 同じサイズで表示のON/OFFを切り替える時
```

#### 解答

```
頻繁に表示・非表示を切り替える際のパフォーマンスは、一般的に
visibility: hiddenの方が優れています。その理由は、ブラウザのレンダリングプロセスにおける「リフロー（Reflow）」と「リペイント（Repaint）」の違いにあります。 
display: noneの場合

    リフローとリペイントが発生: display: noneは要素をドキュメントフローから完全に削除します。そのため、表示・非表示のたびにページのレイアウトが再計算され（リフロー）、その後で再描画（リペイント）が行われます。
    レイアウトの再計算: 要素が消えることでその分のスペースがなくなるため、周囲の要素が詰めるように配置され直します。この再計算の処理がパフォーマンスに影響を与えます。
    頻繁な切り替えには不向き: 要素の数が多かったり、レイアウトが複雑だったりする場合、リフローのコストが大きくなるため、頻繁に切り替えるとパフォーマンスが低下します。 

visibility: hiddenの場合

    リフローは発生しない: visibility: hiddenは要素を非表示にするだけで、ドキュメントフロー上のスペースは確保したままになります。要素のレイアウト（位置やサイズ）は変わらないため、リフローは発生しません。
    リペイントのみ発生: 表示・非表示を切り替える際には、要素の再描画（リペイント）だけが行われます。
    頻繁な切り替えに有利: リフローが発生しない分、display: noneよりも高速に切り替えを行うことができます。 

結論
同じサイズで表示のON/OFFを頻繁に切り替えるケースでは、要素のスペースを維持したまま非表示にするvisibility: hiddenが、ブラウザのリフロー処理を回避できるため、パフォーマンス面で有利です。 
一方、要素を完全にドキュメントフローから削除して、レイアウトを詰める必要がある場合は、display: noneを使用します。ただし、その場合は切り替えのたびにリフローが発生することに注意が必要です。 
```

### UI

```
ページ表示方式-+
| display      |
| visibility   |
+--------------+
補足説明
* display: ページ遷移する度にリフローが発生し遅延する
* visibility: 全ページ領域分のスクロールが表示される
```

### スクロールバー無効化

```
CSSを使用してHTMLドキュメントのスクロールバーを完全に非表示にするには、ブラウザごとに異なるアプローチが必要になります
。スクロール操作自体は可能にしたまま、スクロールバーだけを非表示にする方法と、スクロール機能自体を無効にする方法があります。 
スクロール機能を残したまま、スクロールバーを非表示にする 
この方法では、ユーザーはマウスホイールやトラックパッドなどでスクロールできますが、スクロールバーは表示されません。 
すべてのブラウザに対応するCSS
以下の方法が、主要なモダンブラウザ（Chrome, Firefox, Safariなど）のほとんどに対応しています。
overflow: hidden を使用した古い手法は、スクロール機能自体を無効化するため注意が必要です。 
親要素にスタイルを適用する
親要素で overflow: hidden を設定し、子要素に十分な幅や高さを与えてから、子要素で overflow: scroll を設定します。 
css

.container {
  /* スクロールバーの幅の分だけ要素を広げる */
  width: calc(100% + 15px); /* スクロールバーの幅を考慮 */
  height: 100vh;
  overflow: hidden;
}

.content {
  /* 親要素で隠れたスクロールバーの分を調整 */
  width: 100%;
  height: 100%;
  overflow: scroll;
}

ブラウザ固有のプレフィックスを使用する
モダンブラウザのほとんどはベンダープレフィックスを利用することで、スクロールバーを非表示にできます。 

    WebKitベースのブラウザ（Chrome, Safariなど）
    css

.element::-webkit-scrollbar {
  display: none;
}

または、
css

.element::-webkit-scrollbar {
  width: 0;
  height: 0;
}

Firefox
css

.element {
  scrollbar-width: none;
}

Microsoft Edge（古いバージョン）
css

.element {
  -ms-overflow-style: none;
}

 

スクロール機能自体を無効にする 
スクロール操作自体を完全に無効にしたい場合は、overflow: hidden; を使用します。この方法は最もシンプルですが、要素の隠れた部分はユーザーがアクセスできなくなります。 
css

body {
  overflow: hidden;
}

または、特定の要素のみに適用する場合:
css

.element {
  overflow: hidden;
}
```


```
CSSでスクロールバーを完全に非表示にするには、ブラウザごとに対応する方法を組み合わせます。具体的には、Firefoxでは scrollbar-width: none; を、Chrome、Safari、Edgeでは ::-webkit-scrollbar { display: none; } を使用します。﻿
複数のブラウザに対応させるコード例
ソースコード

/* Firefox */
.element {
  scrollbar-width: none;
}

/* Chrome, Safari, Edge */
.element::-webkit-scrollbar {
  display: none;
}

使い方

    非表示にしたい要素にクラス名を指定する:
    コード例の .element の部分を、スクロールバーを非表示にしたいHTML要素のクラス名に置き換えます。﻿

CSSを適用する:
上記のCSSコードをウェブサイトのスタイルシートに記述します。﻿
IE/Edge用（古いブラウザ）:

    古いEdgeとInternet Explorer向けに、 -ms-overflow-style: none; を追加することもできます。﻿

IEはすでに終了していますが、過去のブラウザへの対応が必要な場合に記述します。﻿

注意点

    scrollbar-width: none; を指定すると、スクロールバーは非表示になりますが、要素自体はスクロール可能なままです。﻿

overflow: hidden; を使用すると、スクロールバーだけでなく、あふれた内容自体も非表示になるため、意図した表示と異なる場合があります。﻿
```



