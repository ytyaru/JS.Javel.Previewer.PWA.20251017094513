# 日本語用小説アプリ

## 既存

　色々試してみた過去案件。

キーワード：javel,novel

プロジェクト：
https://github.com/ytyaru/JS.Javel.Parser.20250718105402
https://github.com/ytyaru/Html.VanJS.Javel.Parser.20240524100007
https://github.com/ytyaru/Html.Javel.Writer.Mini.VanJS.20231201091159
https://github.com/ytyaru/Python.Eel.VanJS.Javel.Writer.20240131114904

https://github.com/ytyaru/Html.JS.Novel.Parser.20230407134853
https://github.com/ytyaru/Html.CSS.Novel.Setting.Dialog.20211225195150
https://github.com/ytyaru/JS.Novel.Parser.Loader.20210216091021
https://github.com/ytyaru/JS.Novel.Package.20210215094114
https://github.com/ytyaru/JS.Novel.CharactorCounter.20210215120242

https://github.com/ytyaru/JS.TatelevoN.TopEdge.RadioButton.DomMapper.Storage.20210215175829
https://github.com/ytyaru/JS.TatelevoN.jQuery.20210120145241
https://github.com/ytyaru/JS.TatelevoN.Vue.20210122094419

https://github.com/ytyaru/NovelWriter400.201706161317

　色々試して判明したこと。

* ページ計算
    * 画面に要素を表示する必要がある
        * 本当は隠したい
    * 時間がかかる（数秒〜数分〜）
        * PWAの[Worker][]を使ってもUI処理はマルチスレッド化できない
            * ページ分割計算には[getBoundingClientRect][]を使用するが、[document][]に[append][]しないと全項目`0`を返す
            * でも[Worker][]に[document][]は渡せない。[document][]のようなUI処理はメインスレッドでのみ可能
            * よって時間のかかるページ分割処理を[Worker][]でバックグラウンド処理してユーザの待機時間を減らすことはできない。対案は以下
                * Loading画面で待機させる：最初にめちゃ時間かかる
                * 一ページずつ読み込ませる：最終ページを捲るまでいつ終わるか判らない
                * 5秒ずつ自動読込：計算中にユーザ操作しても無視されてしまう
                    * 計算中はフリーズするので待機時間を長めにしてUI受付時間を引き伸ばせるが、計算完了までの時間も伸びてしまう


[getBoundingClientRect]:https://developer.mozilla.org/ja/docs/Web/API/Element/getBoundingClientRect
[document]:https://developer.mozilla.org/ja/docs/Web/API/Document
[Worker]:https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Using_web_workers

## データ形式

* File(Javel形式(YAML,Markdown,青空文庫風)。軽量マークアップ言語)
* HTML内包Javel(`<textarea readonly>`)
* HTML(ページ分割済み。本文や原稿内での位置特定可能なように属性付与したHTML要素。ここからJavel原稿の復元が可能)
* IndexedDB
* SQLite3
* Files(単一著者(self, workHeaders, workContents)、多数他著者(authors, workHeaders, workContents)、GZip圧縮)
* RDBMS

## 実装

　実装したい機能が多すぎて一つのアプリにまとめきれない。そこで小さく分離して実装したい。

機能|概要
----|----
Previewer|簡易記法テキストファイルをHTML化して表示する
Bundler|簡易記法テキストファイルをHTMLファイル化してダウンロードする（URL引数で栞・ページ分割・フッタ・コメント表示等を制御できる）
Editor|簡易記法テキストファイルを作成・編集するUI（IndexedDBでも管理可能）
Publisher|サイト投稿する（IndexedDBで管理する。外部SQLite3DBのコンテンツ投稿も可能。リビジョン管理しdiffデータを含める）
Finder|投稿サイトを探す（Webから探す）
Commenter|コメント・指摘・感想・意見・評価する（小説内に追記できる。SNSに投稿できる。独自感想・評価サイトを投稿できる）
Printer|印刷用HTMLを生成する（8p/16p、平綴じ、中綴じ、無線綴じ用にページ構成する（ページ順序、余白等））
Viewer|Previewer+Bundler+Finder+Commenter
Writer|Editor+Publisher+Commenter(指摘)

機能|概要
----|----
Previewer|原稿やページ設定を自由に変更できるが、栞機能がない。
Viewer|原稿は固定だが、栞機能がある。

```
https://javel/preview.html?manuscript=...&width=1920...&page=1...&bis=1&bie=1&nis=1&nie=1&mis=3&mie=29
```
```
https://javel/preview/api.html?manuscript=...&width=1920...&page=1...&bis=1&bie=1&nis=1&nie=1&mis=3&mie=29
```
```
https://javel/work-id/view?page=1...&bis=1&bie=1&nis=1&nie=1&mis=3&mie=29
```


## 機能

1. Viewer
2. Editor
3. Publisher
4. Finder

### 読者

機能|概要
----|----
Viewer|簡易記法テキストをHTML化して表示する
Finder|Web上に存在する著者・作品・テキストを探索する（EditorでPublishした著者を一覧しその作品を選びViewerで表示する）
Printer|印刷する（8p/16p、平綴じ、中綴じ、無線綴じ）

### 筆者

機能|概要
----|----
Editor|UIで入力したデータを簡易記法テキストファイル化してダウンロードする
Publisher|個人単位で作品一覧などを含めてWebに公開する

## Viewer

　ローカル内のみ、デバイス間、ネット間でデータ通信して表示する。

* 単一Javelファイル閲覧
* 複数ファイル閲覧（画像などjavel以外のファイルも含めた`tgz`圧縮ファイル）
* 単一SQLite3DBファイル閲覧（同一著者の複数作品。`.sqlite3`(`.db`)）
* IndexedDB閲覧
* BlueTooth
* URLフェッチ（単一/`tgz`/`db`）
* Web上Javelファイル閲覧
    * リビジョン管理系
        * GitHubリポジトリ内ファイル閲覧（他、GitLab、Bitbucket）
    * ファイルストレージ系
        * DropBox、GoogleDrive, OneDrive, MEGA

### 1. ファイル＆URL

　単一Javelファイルだけを読込対象とする。（原稿は外部ファイルである）

* DnD
* `<input type="file">`
* `<textarea>`
* fetch API

### 2. StandAlone

　原稿を内包したHTML。一冊の本。

サイズ|名称|概要
------|----|----
固定|`Fix`|Parser,Splitterは実行済みのため不要
変動|`Reflow`|Parser,Splitterを内蔵

　URLで特定部位を指定してページを開ける。これは栞、指摘・コメント、テキスト検索・原稿置換で使える。

* 栞
* 指摘・コメント
* テキスト検索・原稿置換

略名|部位指定属性|概要
----|------------|----
`bi`|text-block-id|テキストブロックの添字
`si`|page-split-id|テキストブロックがページ間で分割された場合の添字
`ni`|block-in-text-id|テキストブロック内におけるノードの添字（`<ruby>`やTextNodeなどのインライン要素単位）
`ti`|node-in-text-id|ノード内におけるテキストの添字（`<ruby>`などのElementNodeは`0`固定つまり必ず先頭から始まる。TextNodeは任意位置を指定可）
`mi`|manuscript-text-id|原稿内におけるテキストの添字（フロントマターやメタ文字も含んだ位置）

　画面サイズが変わると`si`も変わってしまう。よって不変の絶対値として指定したい場合には不適切。
　もし不変の絶対値として本文中の位置を指定するなら、原稿に対するテキスト位置で指定すべき。
　たとえば`<ruby>`要素の簡易構文はメタ文字を含むため、原稿内における添字とHTML内における添字が異なる。HTML要素から原稿内添字を取得するには、パース時点で原稿内添字を取得し、それをHTML要素にセットしておく必要がある。以下のように。`data-rng`は原稿内における当該要素の開始位置と終了位置を示す添字。

```html
これは最初《さいしょ》の｜段落《だんらく》です。
```
```html
<p data-bi="0">これは<ruby data-ni="1" data-rng="3,10">最初<rt>さいしょ</rt><ruby>の<ruby data-ni="3" data-rng="12,20" data-piped>段落<rt>だんらく</rt></ruby>です。</p>
```

　実際に表示されたHTMLから原稿内添字を取得する方法は以下。

1. ブラウザで表示された本のテキストを範囲選択する
2. 1の見出しか段落要素を取得する
3. 2の`bi`を取得する
4. 1の開始Nodeと終了Nodeを取得し、それぞれ以下のように原稿内添字を取得する
    A. もしNodeがElementNodeなら
        1. `data-rng`の開始/終了位置を取得する(`data-rng[0/1]`)
    B. もしNodeがTextNodeなら
        1. 開始Nodeにおける原稿内での添字を算出する
            1. 同一`bi`内にある全Nodeを取得し、以下ループする
                1. 4の開始/終了Nodeが来るまで繰り返す
                1. 対象Nodeの添字を取得する(`ni`とする)
                1. 対象Node内のテキスト添字を取得する(`ti`とする)
                    1. もしNodeがElementNodeなら`data-rng[0/1]`
                    2. もしNodeがTextNodeなら`node.textContent.Grapemes.length`(開始Node:`0`, 終了Node:`選択テキストの末尾から一字ずつ切り出して終了Node.textContent.indexOf(末尾n字)して-1を返す直前までの文字列を探す。その末尾から一字ずつ切り出したテキストの長さ。`)
5. URL引数にする(`?biRng=${start,end}&niRng${start,end}&tiRng=${start,end}`)

　もし栞なら終了位置は不要。以下のようになる。終了位置はそのブロックの末尾である。

`?bi=${start}&ni=${start}&ti=${start}`

　指摘・コメント・置換はこのHTML内位置に対して任意のテキストも追加する。該当部位をタップ・クリック・Enterキー押下すると任意テキストの表示／非表示が切り替わる。オーバーレイ表示されるため、本文の一部は隠れてしまう。但し対象HTML内位置の部分は隠れないよう調整する。指摘(`point`)は置換(`replace`)と一緒にしたほうがいいか。

```
point=指摘
comment=コメント
replace=置換する原稿
```

　置換時に必要な原稿の取得方法は以下。（必ずしも原稿添字を算出する必要はない。`bi`という相対位置で十分対応可）

1. 原稿のテキストブロック配列を参照する
1. `bis`に該当するテキストブロック要素を取得する
2. `nis`, `tis`に該当するテキストブロック要素内のJavel原稿を取得する
    1. `bis`に該当する原稿をHTMLにパースして取得する
    2. `nis`の直前までの原稿字数をカウントする
        A. ElementNodeなら`data-rng[1]-[0]+1`
        B. TextNodeなら`textContent.Graphemes.length`
    3. 2の字数+`tis`に該当する原稿内テキストが置換対象部分である

　ブロック間をまたぐと面倒になる。置換はブロック内に限定したほうが引数が簡単になる。が、複数のブロックをまたいだ大量置換をしたい場合もありうる。大は小を兼ねるため、ブロック間をまたいで置換可能にすべき。

### 3. Author

　一人の著者が書いた作品一覧と作品表示をする。

* 著者・作品数・字数
* 作品一覧（タイトル、キャッチコピー、帯文、全字数、完結是非、カテゴリ・ジャンル・タグ・警告、キーワード検索）
* 個別作品表示

　全データをSQLite3に保存すれば集計も可能。だが量が増えるとロードに時間がかかるようになってしまう。そこで、次のようにテキストファイルに分割する。

* author.yml
* works.yml
* works/
    * work-id.jv
    * ...
    * work-id.jv

　あるいはヘッダと本文を別DBファイルに分割すればいいかもしれない。だが、テキストファイルでないため、メモ帳による編集ができなくなってしまう。

* author.yml
* headers.db
* contents.db

　問題はメタデータと本文の整合性が取れないこと。テキストファイルを手動で変更したら、その文字数などのメタデータも修正する必要があるが、そこを自動化しないと修正し忘れなどのミスが起きる。これを失くすためにも専用エディタで編集することが望ましい。

　そもそもファイル化した所で、タイトルなどのメタデータは別ファイル化されているため、単一ファイルでは機能しない。

* メタデータの重複を失くすためにファイル分割する
* メタデータの重複を承知の上で完全なJavel形式ファイルを生成する

　前者をベースとし、場合によっては完全Javelファイル生成もする。

* javel-writer-datas/
    * author.yml
    * works.yml             タイトルなどメタデータのみ
    * works/                本文のみ
        * work-id.jvc
        * ...
        * work-id.jvc
* output/
    * work-id.jv            メタデータ＋本文
    * ...                   メタデータ＋本文
    * work-id.jv            メタデータ＋本文

　拡張子により差別化を図る。

Javelテキスト|拡張子
-------------|------
本文のみの|`jvc`
メタデータも含む|`jv`,`javel`

　パフォーマンス問題について考慮しておきたい。メタデータのみだとしても作品数が増えれば膨大な量になる。

* ID（UUIDv7） 36字（UUIDv7は16進数+ハイフン区切り36字。単一バイナリをBase64にしたら22文字になる https://zenn.dev/medirom_tech/articles/ffcf8a6f8f8708 但し_-の字はソータブルでない。Base62のほうが良い。ULIDならBase32なので26字になる。128bit(8Byte)でありSQLite3の整数型と合致する）
* タイトル 40字
* キャッチコピー 35字
* 帯文 200字
* カテゴリ 20字
* ジャンル 20字
* タグ 40字
* 警告 10字
* 合計 365+36=401

　一作品あたり400字のメタデータがあるとして、文字コードがUTF8で、各字が日本語なら3〜4バイトである。400字*4B=1600B=1.6KB。もし100KBを上限とするなら、一ファイルあたり62.5件含めることができる。

A. １ファイルあたり50件固定とする（ファイルサイズ不定。ファイル数が多くなるがファイル数で全数を推測できる）
B. １ファイルあたり100KB上限とする（件数不定。ファイル数を少なくできるが全数は全ファイルを読み込むまで不明）

　Aを採用したい。

　メタデータのパフォーマンス問題を解決するには以下の方法がありえる。

* yaml形式のファイルをgzip圧縮する（メモ帳による編集不可になる）
* 100KBなど上限値毎にファイル分割する（ランダム性の喪失。全体からランダム表示するとき先頭ファイルほど先に表示されやすくなる）

　ファイル分割する方法が最適と考える。

* javel-writer-datas/
    * author.yml
    * headers/              タイトルなどメタデータのみ
        * 0.yml
        * 1.yml
    * contents/             本文のみ
        * work-id.jvc
        * ...
        * work-id.jvc

　PWAならIndexedDBで保存したほうが便利。但し2GBの上限がある。このIndexedDBから複数ファイル化してGZip圧縮ファイルとしてDLできるようにする。これにてWebでパフォーマンス考慮したファイル参照が可能。またはSQLite3単一ファイルにしてImport/Export可にする。FileSystemlAccessAPIなら直接書き込めるがChrome限定。

* Web上でのパフォーマンスを考慮した複数ファイル分割版
* Web上からDLを考慮した上記のGZip圧縮版
* 全データのBackupやImport/Exportを考慮したSQLite3版

### 4. Multi Author

　複数の著者の作品が混在した一覧と作品視聴。

* 一人の読者が感想・評価・紹介した作品一覧
* プラットフォーマーが不特定多数の著者から作品を投稿させた作品一覧

　魅せ方がまったく別物になるはず。特に感想・評価・紹介に関しては読者自身の価値観にもとづき作品を抽出することになる。何を優先するかも異なる。

　読者は自身の価値観にもとづき序列化／分類化できる。自分の価値観を紹介し、それにもとづき作品を評価する場所になる。読者自身にとっては宝の山になるし、要らないものを見せしめにする場にもなる。

* 自分の価値観を定義する
* 自分の価値観にもとづき評価観点を抽出する
* 自分の評価観点にもとづき評価コメントを書き、採点する
* 自分の評価方法を作る（加点式、減点式など。評価方法は一つに統一する必要はない。複数の方法を用意して、各方法で各作品を評価できる）

　プラットフォーマーであれば作品を紹介することに注力する。なるだけ客観的な分類化や序列化すべき。

　但し、膨大なデータ量になることが想定されるため、SQLite3のようなファイルベースのDBMSでは破綻する。PostgleSQLのようなバックグラウンドで動作するRDBMSを利用すべき。するとHTTPSサーバアプリを開発することになる。それは既存の小説投稿サイトのOSS版みたいなものになるだろう。できればMastodonのように連合機能を兼ね備えたい。(ActivityPub)

### GitHubリポジトリ

　サーバ、ユーザHDDなどのリソース最小化を考慮した実装が困難すぎる。

* 開発者は公開用リポジトリを用意する(`javel-work-share-users/users.txt`)
* 自作品の公開を要望するユーザはGitHubアカウントを取得する
    * `javel-share-works`リポジトリを作成し、`author.json`, `works.tsv`ファイルを作成する
    * 自分のユーザ名を`javel-work-share-users/users.txt`に追記するよう依頼する
        * Issueか何かに特定キーワードを書き込むと自動的に`users.txt`に追記されるようにしたいが、そんなことは可能か？
            * https://docs.github.com/ja/account-and-profile/how-tos/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository
            * GitHub APIで自動化したい
                * GitHub アカウントでログインさせる
                * APIを叩いて自動的にユーザ名を追記させる

　もし自動化できるならユーザ名だけでなく作品のタイトル、キャッチコピー、帯文、完結是非、文字数などのメタデータまで一括変更できるはず。但しリクエスト上限があるはずなので、一人あたり一日一回までとする。

* 一つのファイルに全ユーザの全データをぶちこむ
* ユーザ毎に個別ファイルを作る

　リポジトリあたり1GBしか容量がないはず。なのでタイトルなどの文字列まで含めてしまうとすぐにパンクする。なので以下のようにするのが良いかもしれない。そして作品などの詳細情報は各人のリポジトリ`javel-share-works/works.tsv`を閲覧してもらう。ユーザはローカルに最終更新日時を記録しておき、それを超過しているユーザのみ対象とする。

```
ユーザID    最終更新日時
12345678    2025-01-01 00:00:00
...
ユーザID    最終更新日時
```

項目|文字数
----|------
ユーザID|人数を十進数にした数値の桁数
最終更新日時|19字〜
要素間区切文字|`\t`, `\n`

　文字コードはUTF-8とし、一人当たり30字としたら、30バイト。

1GB=1,000MB=1,000,000KB=1000,000,000B;
1GB/30B=33333333.3333。
3千万人まで受入可能。

　思ったより少ない。超過したら別リポジトリに創りたいが。あるいはユーザにも同じようにユーザ管理するリポジトリを作らせるか？　たとえば仲間同士だけのコミュニティなど。それをブログやSNSで公開し、ユーザはそのURLを入力すれば作品一覧できるようにするとか。

　というか、1GBのユーザ名ファイル読込は重すぎる。できれば日時でソートしたい。100KBずつくらいに分割しないと取得にも時間がかかりすぎる。そもそも日時だけを頻繁に書き換えたりするのは非効率。でも、そうしないと誰を優先して表示するか決められなくなる。いっそ完全ランダムにするか？

　もし表示ユーザに優先度をつけず完全ランダムでいいなら、先着順に100KBずつファイル分割してユーザIDだけを記入していけばいい。各ユーザがローカルに他ユーザIDを記録すれば、いつでも閲覧可能。でも容量が取られる。

　WebAPIで全員の中から更新日時などで表示ユーザの優先度を決定させ、上位順に30名ずつ取得するような機能があればメモリ上だけで処理できるはず。ついでに完全ランダムで30名ずつなどのAPIも欲しい。

　なるだけ少ないメモリで膨大な中から項目を抽出するには、どうしたらいいか？
　100KBなどで区切り、一ユーザ一行ずつデータを追記する。その中にある要素の開始行数〜終了行数、全行数をファイル名として記録する。全ファイルの全行数内で乱数を発生させ、その乱数が含まれているファイルを特定し、そのファイル内における指定行数を取得する。その行に記入されたユーザ名を返す。これにて一回のリクエストあたり一つのファイル100KBを取得するだけで済む。但し、他のユーザも取得する場合は同一ファイル内にあるユーザを対象にしないと、別ファイル読込が必要になってしまう。

　各ユーザがローカル内に100KB内で収まるユーザを記録するようにする。その条件は、お気に入り、最終更新日時が新しい、の二つ。お気に入り著者なら更新日時が古くても保存し続ける。そうでないなら更新日時が古くなり100KBを超えたら消える。このときサーバでは登録順に記録され、ユーザ一覧ファイルには最初と最後のユーザの日時が記録されている。このときユーザはユーザ名取得日時から一ヶ月以内に更新されたユーザだけを取得する。

## アプリIO

　軽量マークアップ言語Javel形式テキストを入力にして、ページ分割したHTMLを表示する。

* 入力
    * 原稿（Javelのみ。小説投稿サイト用の微妙に異なるルビ書式などの別形式テキストは対象外）
    * ページ設定（画面のみ。紙面印刷は対象外）
        * 
* 

* DnD
* UI



