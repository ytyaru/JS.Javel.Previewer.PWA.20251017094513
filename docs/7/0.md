# 分割

　簡易形式テキストを分割して画面内に収まる単位で`<div class="page">`要素を生成する。

データ|概要
-----|----
JavelText|見出し、本文、ルビなどの簡易構文。二連続改行を一block要素とするString(文字列)。
TextBlock|一block要素単位のString配列
BlockElement|一block要素単位のHTMLElement(`<h1>`〜`<h6>`,`<hr>`,`<br>`,`<p>`)
InlineElement|一inline要素単位のHTMLElement(`<ruby>`,`<em>`,`<mark>`,`<span>`,`<div>`)
p|一block要素単位のうちp要素のみ（ページをまたいで分割する要素）
p.childNodes|p内子要素(`TextNode`,`<ruby>`,`<em>`,`<mark>`,`<span>`,`<div>`)
TextNode|p内TextNode
TextNode.Sentences|TextNode内にある文の配列
Sentences.Words|文の中にある語の配列
Word.Graphemes|語の中にある字の配列

## Javel構文

### FrontMatter

　メタ情報のうちファイルの要約を示すもの。

```
---
book:
  title: タイトル 100字迄。
  catch: キャッチコピー 35字迄。
  obi: 帯文 200字迄。
web:
  description: 説明文。80字迄。
  image: https://some.png
  url: https://...
author:
  name: 著者名
volume:
  write:
    all: meta.all + body.all
    meta:
      all: メタ情報文字数
      body: メタ文字を除いたユーザ固有入力値の字数
      meta: メタ情報におけるメタ文字数
    body:
      all: 本文文字数
      body: メタ文字を除いたユーザ固有入力値の字数
      meta: 本文内における#や《》などのメタ文字数
  read:
    all: head+line+ruby+body
    head: write.body.body内にある見出し文字数
    line: write.body.body内にある改行文字数
    ruby: write.body.body内にあるルビ文字数
    excluded: write.body.body内にある対象外の要素内にある文字数（注釈・ステータス・チップスなど主要テキストでない部分）
      status: ステータス文字数
      tips: チップス文字数
      annotation: 注釈文字数
    number: write.body.body内にある数字数（半角、全角。アラビア数字のみ対象。漢数字やギリシャ数字等は対象外）
    alphabet: write.body.body内にあるアルファベット文字数
    signe: write.body.body内にある記号文字数（句読点。、感嘆符！疑問符？括弧類「」『』””）
    emoji: write.body.body内にある絵文字数
    wordy: write.body.body内にある上記以外の文字のうち連続して繰り返している部分（あーー、あああ、GAAAA等）
    other: write.body.body内にある日本語や上記以外の文字
    body: write.body.body内にある上記以外の文字数（write.body.bodyからルビ文字、改行、見出しを除いた日本語文字数（ひらがな、カタカナ、漢字））
---
```

### Volume

　メタ情報のうちファイルの規模（文字数）を示すもの。

```
---
volume:
  headings:
    - 99    h1数
    - 999   h2数
    - 9999  h3数
  chars:
    write:
      all: meta.all + body.all
      meta:
        all: メタ情報文字数
        body: メタ文字を除いたユーザ固有入力値の字数
        meta: メタ情報におけるメタ文字数
      body:
        all: 本文文字数
        body: メタ文字を除いたユーザ固有入力値の字数
        meta: 本文内における#や《》などのメタ文字数
    read:
      all: head+line+ruby+body
      head: write.body.body内にある見出し文字数
      line: write.body.body内にある改行文字数
      ruby: write.body.body内にあるルビ文字数
      hr: write.body.body内にあるhr要素が示す文字数（`■□■□■□`, `誰々視点――`等場面転換に利用するテキスト）
      excluded: write.body.body内にある対象外の要素内にある文字数（注釈・ステータス・チップスなど主要テキストでない部分）
        status: ステータス文字数
        tips: チップス文字数
        annotation: 注釈文字数
        bbs: 掲示板
        chat: チャット
      number: write.body.body内にある数字数（半角、全角。アラビア数字のみ対象。漢数字やギリシャ数字等は対象外）
      alphabet: write.body.body内にあるアルファベット文字数
      signe: write.body.body内にある記号文字数（句読点。、感嘆符！疑問符？括弧類「」『』””）
      emoji: write.body.body内にある絵文字数
      wordy: write.body.body内にある上記以外の文字のうち連続して繰り返している部分（あーー、あああ、GAAAA等）
      other: write.body.body内にある日本語や上記以外の文字
      talk: write.body.body内にある日本語や上記以外の会話文（「」内に含まれるテキスト）
      narrative: write.body.body内にある日本語や上記以外の地の文（「」内に含まれないテキスト）
      body: write.body.body内にある上記以外の文字数（write.body.bodyからルビ文字、改行、見出しを除いた日本語文字数（ひらがな、カタカナ、漢字））
---
```

　筆者は`write.all`、読者は`read.body`を見るとそれぞれの規模を知れる。

* `narrative`はさらに「状況説明文」や登場人物の心の中における思考である「モノローグ」などに細分化可能だが、そこまで分ける必要性は低いだろう
* `"引用文"`のように引用したテキストも分類可能だが、そこまで細分化する必要性はないだろう
* `《スキル名》`のように固有名詞も分類可能だが、そこまで細分化する必要性はないだろう

### Page

　メタ情報のうちページ分割した情報のキャッシュを示すもの。これはページ分割処理した結果を記録することで次回起動時に再計算せず即表示するためのものである。

```
---
page:
  css:
    size:
      inline: 640px
      block: 480px
    writingMode: vertical-rl
    textOrientation: upright
    lineHeight: 1.7em
    letterSpacing: 0.05em
    column:
      count: 1
      gap: 2em
    font:
      family:
        heading: ["Noto Sans JP"]
        paragraph: ["Noto Serif JP"]
      size: 16px
  split:
    length: 99
---

= 1 0

= 2 5

= 3 7 -1 0

= 4 8 1

= 5 9 2 -1

= 6 10

= 7 15
```

　書式は`= pageNum blockIndex splitIndexH splitIndexT`。行頭が`= `の部分は一ページ単位である。`blockIndex`はそのページ

識別子|概要
------|----
pageNum|1から始まるページ数。
blockIndex|`<h1>`,`<p>`のブロック要素に`0`から始まる番号を付与する。`<p data-bi="0">`のように。該当ページの先頭ブロック要素が対象。
splitIndexHead|ページ間をまたいで`<p>`要素を分割した時の0から始まる番号。`<p data-bi="7" data-si="0">`のように。該当ページの先頭ブロック要素が対象。
splitIndexTail|ページ間をまたいで`<p>`要素を分割した時の0から始まる番号。`<p data-bi="7" data-si="0">`のように。該当ページの末尾ブロック要素が対象。

　実際に必要なのは`splitIndex`だけ。他は内部でカウントすれば得られる。

### 企画

　作品の物語を示す骨子。

```
---
spec:
  tagline: 20字迄。
  logline: 200字迄。
  pitch: 800字迄。
  synopsis: 2000字迄。
  bsSheet:
    - opening
  plot: 
---
```

### 表記パターン

#### 最小系

```
# タイトル https://このファイル自体またはそれを表示する代表URL
## 著者名 https://著者を示す代表URL
### キャッチコピー

　帯文。

# 最初の見出し
```

　URLは任意。無くても良い。

　最初の見出し`# `の前にFrontMatterが存在しない。

#### 拡張系

```
# タイトル
## 著者名
### キャッチコピー

　帯文。

---
web:
  description: 説明文。80字迄。
  image: https://some.png
  url: https://...
---

# 最初の見出し
```

　最初の見出し`# `の後にFrontMatterが存在する。タイトル、著者名、キャッチコピー、帯文以外のメタ情報を追記したFrontMatterを追記する。

#### FrontMatter版（メタ情報はすべてFrontMatter記法で記述する）

　この記法だけに絞ったほうが解析は簡単だし、表記方法も覚えやすい。但しメタデータのキー名を覚えねばならないのは面倒。

```
---
book:
  title: 主題《タイトル》
  catch: キャッチコピー
  obi: |-
    帯文《おびぶん》。

    二段落目。
    Javel形式で書く。
  url: 
    file: https://book.javel
    view: https://book.html
  date:
    created: 2020-01-01 00:00:00
    updated: 2020-01-01 00:00:00
    published: 2020-01-01 00:00:00
  revisions:
    - {date:"2020-01-01 00:00:00", diff:""}
author:
  name: 著者名
  url: https://author.html
---

# 最初の見出し
```


## 一括

　Javelテキストから一括変換する。高速だが長文になると長期フリーズする。

```javascript
const parser = new JavelParser();
parser.text = 'Javel原稿';
parser.els; // [Element, ...]
const splitter = new PageSplitter(Dom.q('[name="book"]'));
splitter.split(parser.els);
```

## TextBlock単位

　JavelテキストをTextBlock単位で変換する。低速だが長文でもフリーズしにくい。

```javascript
const parser = new JavelParser();
const splitter = new PageSplitter({
  root: Dom.q('[name="book"]'),
  createdPage: (page, pageNum)=>pages.length, 
  finished: (pages)=>pages.length,
});
for (let el of parser.generate('Javel原稿')) {
  splitter.addElement(el);
}
```

## 表紙＆本文

　Javelテキストを表紙と本文に分割して変換する。

```javascript
const parser = new JavelParser('Javel原稿');
parser.manuscript        // 原稿（改行を\nに統一したり不要な改行を最小化してフォーマット統一された原稿テキスト）
// 表紙
parser.cover.manuscript  // 原稿メタ情報の原文
parser.cover.keys        // 原稿メタ情報のキー
parser.cover.javel.title // 原稿メタ情報を取得する（原文のまま）
parser.cover.text.title  // 原稿メタ情報を取得する（原文が`漢字《かんじ》`なら['漢字', 'かんじ']の二つのテキストが生成される。テキスト検索時に利用する）
parser.cover.el.title    // 原稿メタ情報のHTML要素を取得する
// 本文
parser.body.manuscript   // 原稿の本文
const splitter = new PageSplitter({
  root: Dom.q('[name="book"]'),
  createdPage: (page, pageNum)=>pages.length, 
  finished: (pages)=>pages.length,
});
for (let el of parser.generate()) {
  splitter.addElement(el);
}
```

## 規模

* 不特定多数の著者
    * 著者
        * 作品
            * タイトル（100字）
            * キャッチコピー（35字）
            * 帯文（200字）
            * ジャンル（20字）
            * 文字数

* データ単位
    * テキストファイル
    * SQLite3DBファイル

## Yaml→Object/Map

```yaml
book:
 title: タイトル
```
```javascript
const obj = jsyaml.load(yamlText);
obj.book.title // タイトル
objpath.obj = obj;
objpath.get() // rootObject
objpath.get('book.title') // タイトル
objpath.set('book.title', '新タイトル')
objpath.has('book.title')
objpath.keys()
objpath.values()
objpath.entries()
```

# Thread, Async, Generator

　ページ分割途中で既に分割された任意のページをボタン入力に応じて表示したかったが、フリーズするせいで入力不能だった。対案としては次の二つが考えられる。

* シングルスレッドの場合：async/awaitで処理の途中にイベントループを解放しUI処理に戻す。このとき停止時間を2000msにすれば、その時間だけボタン入力が可能になる。但し同じ時間だけページ分割処理が停止する。
* マルチスレッドの場合：HTTPS上でないと動作しない（`file://`上では動作しない）

Thread|Async|Generator|表示氷結|入力氷結
------|-----|---------|--------|--------
-|-|-|☠|☠
-|-|o|☠|☠
-|o|-|?|?
-|o|o|△|☠
o|o|o|?|?

```javascript
window.addEventListener('DOMContentLoaded', async(event) => {
  for await (let page of C.generateAsync()) {
    // 進捗率表示
  }
});
class C {
  async *generateAsync() {
    await new Promise(resolve => setTimeout(resolve, 0)); // イベントループを解放
  }
}
```

## 進捗率の算出

```javel
　一《ひと》つの《《ブロック》》。
```
```html
<p><ruby>一<rp>（</rp><rt>ひと</rt><rp>）</rp></ruby>つの<em>ブロック</em>。</p>
```

i|node.type|textContent
-|---------|-----------
0|`Node.ELEMENT_TYPE`|`<ruby>一<rp>（</rp><rt>ひと</rt><rp>）</rp></ruby>`
1|`Node.TEXT_TYPE`|`つの`
0|`Node.ELEMENT_TYPE`|`<em>ブロック</em>`
0|`Node.ELEMENT_TYPE`|`。`

　進捗率の算出はJavelテキストのlengthをベースにする。

　一つのNode、一つの字、単位で進捗率を算出したい場合、Node単位のJavel形式テキストをどうやって抽出するかが課題になる。

　たとえば`<ruby>`要素に該当するJavelテキストは`｜一《ひと》`の部分だが、省略形`一《ひと》`で表現することも可能である。これをどうやって取得するか。

```javascript
class JavelParser {
  
}
const nodes = blockParser.parseInline(block); // block内にあるinline部分に分割する

```


