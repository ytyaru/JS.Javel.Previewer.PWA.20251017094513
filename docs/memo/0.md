# 日本語用小説アプリ

## 既存

　色々試してみた過去案件。

キーワード：javel,novel

プロジェクト：
https://github.com/ytyaru/JS.Javel.Parser.20250718105402
https://github.com/ytyaru/Html.VanJS.Javel.Parser.20240524100007
https://github.com/ytyaru/Html.Javel.Writer.Mini.VanJS.20231201091159
https://github.com/ytyaru/Python.Eel.VanJS.Javel.Writer.20240131114904

https://github.com/ytyaru/Html.JS.Novel.Parser.20230407134853
https://github.com/ytyaru/Html.CSS.Novel.Setting.Dialog.20211225195150
https://github.com/ytyaru/JS.Novel.Parser.Loader.20210216091021
https://github.com/ytyaru/JS.Novel.Package.20210215094114
https://github.com/ytyaru/JS.Novel.CharactorCounter.20210215120242

https://github.com/ytyaru/JS.TatelevoN.TopEdge.RadioButton.DomMapper.Storage.20210215175829
https://github.com/ytyaru/JS.TatelevoN.jQuery.20210120145241
https://github.com/ytyaru/JS.TatelevoN.Vue.20210122094419

https://github.com/ytyaru/NovelWriter400.201706161317

　色々試して判明したこと。

* ページ計算
    * 画面に要素を表示する必要がある
        * 本当は隠したい
    * 時間がかかる（数秒〜数分〜）
        * PWAの[Worker][]を使ってもUI処理はマルチスレッド化できない
            * ページ分割計算には[getBoundingClientRect][]を使用するが、[document][]に[append][]しないと全項目`0`を返す
            * でも[Worker][]に[document][]は渡せない。[document][]のようなUI処理はメインスレッドでのみ可能
            * よって時間のかかるページ分割処理を[Worker][]でバックグラウンド処理してユーザの待機時間を減らすことはできない。対案は以下
                * Loading画面で待機させる：最初にめちゃ時間かかる
                * 一ページずつ読み込ませる：最終ページを捲るまでいつ終わるか判らない
                * 5秒ずつ自動読込：計算中にユーザ操作しても無視されてしまう
                    * 計算中はフリーズするので待機時間を長めにしてUI受付時間を引き伸ばせるが、計算完了までの時間も伸びてしまう


[getBoundingClientRect]:https://developer.mozilla.org/ja/docs/Web/API/Element/getBoundingClientRect
[document]:https://developer.mozilla.org/ja/docs/Web/API/Document
[Worker]:https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Using_web_workers

## 機能

1. Viewer
2. Editor
3. Publisher
4. Finder

### 読者

機能|概要
----|----
Viewer|簡易記法テキストをHTML化して表示する
Finder|Web上に存在する著者・作品・テキストを探索する（EditorでPublishした著者を一覧しその作品を選びViewerで表示する）

### 筆者

機能|概要
----|----
Editor|UIで入力したデータを簡易記法テキストファイル化してダウンロードする
Publisher|個人単位で作品一覧などを含めてWebに公開する

## Viewer

　ローカル内のみ、デバイス間、ネット間でデータ通信して表示する。

* 単一Javelファイル閲覧
* 複数ファイル閲覧（画像などjavel以外のファイルも含めた`tgz`圧縮ファイル）
* 単一SQLite3DBファイル閲覧（同一著者の複数作品。`.sqlite3`(`.db`)）
* IndexedDB閲覧
* BlueTooth
* URLフェッチ（単一/`tgz`/`db`）
* Web上Javelファイル閲覧
    * リビジョン管理系
        * GitHubリポジトリ内ファイル閲覧（他、GitLab、Bitbucket）
    * ファイルストレージ系
        * DropBox、GoogleDrive, OneDrive, MEGA

### ファイル＆URL

　単一Javelファイルだけを読込対象とする。

* DnD
* `<input type="file">`
* `<textarea>`
* fetch API

### GitHubリポジトリ

　サーバ、ユーザHDDなどのリソース最小化を考慮した実装が困難すぎる。

* 開発者は公開用リポジトリを用意する(`javel-work-share-users/users.txt`)
* 自作品の公開を要望するユーザはGitHubアカウントを取得する
    * `javel-share-works`リポジトリを作成し、`author.json`, `works.tsv`ファイルを作成する
    * 自分のユーザ名を`javel-work-share-users/users.txt`に追記するよう依頼する
        * Issueか何かに特定キーワードを書き込むと自動的に`users.txt`に追記されるようにしたいが、そんなことは可能か？
            * https://docs.github.com/ja/account-and-profile/how-tos/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository
            * GitHub APIで自動化したい
                * GitHub アカウントでログインさせる
                * APIを叩いて自動的にユーザ名を追記させる

　もし自動化できるならユーザ名だけでなく作品のタイトル、キャッチコピー、帯文、完結是非、文字数などのメタデータまで一括変更できるはず。但しリクエスト上限があるはずなので、一人あたり一日一回までとする。

* 一つのファイルに全ユーザの全データをぶちこむ
* ユーザ毎に個別ファイルを作る

　リポジトリあたり1GBしか容量がないはず。なのでタイトルなどの文字列まで含めてしまうとすぐにパンクする。なので以下のようにするのが良いかもしれない。そして作品などの詳細情報は各人のリポジトリ`javel-share-works/works.tsv`を閲覧してもらう。ユーザはローカルに最終更新日時を記録しておき、それを超過しているユーザのみ対象とする。

```
ユーザID    最終更新日時
12345678    2025-01-01 00:00:00
...
ユーザID    最終更新日時
```

項目|文字数
----|------
ユーザID|人数を十進数にした数値の桁数
最終更新日時|19字〜
要素間区切文字|`\t`, `\n`

　文字コードはUTF-8とし、一人当たり30字としたら、30バイト。

1GB=1,000MB=1,000,000KB=1000,000,000B;
1GB/30B=33333333.3333。
3千万人まで受入可能。

　思ったより少ない。超過したら別リポジトリに創りたいが。あるいはユーザにも同じようにユーザ管理するリポジトリを作らせるか？　たとえば仲間同士だけのコミュニティなど。それをブログやSNSで公開し、ユーザはそのURLを入力すれば作品一覧できるようにするとか。

　というか、1GBのユーザ名ファイル読込は重すぎる。できれば日時でソートしたい。100KBずつくらいに分割しないと取得にも時間がかかりすぎる。そもそも日時だけを頻繁に書き換えたりするのは非効率。でも、そうしないと誰を優先して表示するか決められなくなる。いっそ完全ランダムにするか？

　もし表示ユーザに優先度をつけず完全ランダムでいいなら、先着順に100KBずつファイル分割してユーザIDだけを記入していけばいい。各ユーザがローカルに他ユーザIDを記録すれば、いつでも閲覧可能。でも容量が取られる。

　WebAPIで全員の中から更新日時などで表示ユーザの優先度を決定させ、上位順に30名ずつ取得するような機能があればメモリ上だけで処理できるはず。ついでに完全ランダムで30名ずつなどのAPIも欲しい。

　なるだけ少ないメモリで膨大な中から項目を抽出するには、どうしたらいいか？
　100KBなどで区切り、一ユーザ一行ずつデータを追記する。その中にある要素の開始行数〜終了行数、全行数をファイル名として記録する。全ファイルの全行数内で乱数を発生させ、その乱数が含まれているファイルを特定し、そのファイル内における指定行数を取得する。その行に記入されたユーザ名を返す。これにて一回のリクエストあたり一つのファイル100KBを取得するだけで済む。但し、他のユーザも取得する場合は同一ファイル内にあるユーザを対象にしないと、別ファイル読込が必要になってしまう。

　各ユーザがローカル内に100KB内で収まるユーザを記録するようにする。その条件は、お気に入り、最終更新日時が新しい、の二つ。お気に入り著者なら更新日時が古くても保存し続ける。そうでないなら更新日時が古くなり100KBを超えたら消える。このときサーバでは登録順に記録され、ユーザ一覧ファイルには最初と最後のユーザの日時が記録されている。このときユーザはユーザ名取得日時から一ヶ月以内に更新されたユーザだけを取得する。

## アプリIO

　軽量マークアップ言語Javel形式テキストを入力にして、ページ分割したHTMLを表示する。

* 入力
    * 原稿（Javelのみ。小説投稿サイト用の微妙に異なるルビ書式などの別形式テキストは対象外）
    * ページ設定（画面のみ。紙面印刷は対象外）
        * 
* 

* DnD
* UI



